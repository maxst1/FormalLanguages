# FormalLanguages. Задача 18
Решение задачи основано на динамическом программировании. Мы читаем входную регулярку по одному символу слева направо. Если читаем букву или 1, то записываем ее в стэк как решенный токен, если читаем оператор, то используем 1 или 2(в зависимости от оператора) решенных токена в стэке, для создания нового решененного токена для операции. В некоторых случаях операторы '.' и '+' не имеют однозначного решения на каких-то этапах и поэтому мы рекурсивно решаем для обоих возмоножных, выбирая лучший из них в качестве решения. Ввиду этого асимптотика алгоритма в худшем случае будет иметь вид O(2^(кол-во '.' + кол-во '+')) , но в среднем будет O(длина регулярки) поскольку мы 1 раз по не проходим без вложенных циклов. 
Сам токен представляет собой класс с полями: int value - наилучшее решение для токена, bool open - ответ на вопрос можем ли мы увеличить решение приписывая соответсвующий символ к токену справа, bool canBeEmpty - может ли токен быть пустым словом. Хэндлеры операций используют эти данные для создания нового правильно решенного токена или веток рекурсии. 
Корректность регулярки проверяется по ходу решения. Условия ошибки: стэк не имеет длину 1 в конце, при чтений операции * стэк пуст. При чтении операций '.' или '+' в стэке меньше 2 элементов. А также вначале проверка есть в регулярке символы не из алфавита и корректность формата ввода (регулярка символ)


Makefile состоит из run и test.
В наличии есть тесты на корректность ввода, корректность регулярки, и правильный ответ.
